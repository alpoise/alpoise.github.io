---
title: "策略尝试一"
output: github_document
author: '张鑫'
---

数据读入，取螺纹铁矿主力合约日收盘价。
```{r,results='hide',warning=FALSE}
setwd("/Users/Alpoise/Desktop/Pair_Trading")
library(timeSeries)
data <- read.csv('data/I_RB_cl.csv', header = T)
I <- timeSeries(data[ ,2], as.Date(data[ ,1]))
Rb <- timeSeries(data[ ,3], as.Date(data[ ,1]))
```

策略描述：每120天做线性回归得到斜率截断，进而生成下一个120天配对的价差序列。选取阈值{a > b > c > d}使得超过a或低于d时开仓，相应地到b或者到c时平仓。当期满即每120天结束时强行平仓。首先进行线性回归，得到价差序列。
```{r}
block = 120
numblock = floor(length(I) / block)
trainresid = c()
testresid = c()
for(k in 1:(numblock-1)){
    traindat = data[((k-1)*block+1):(k*block),]
    testdat = data[(k*block+1):((k+1)*block),]
    trainlm = lm(traindat$RB.SHF ~ traindat$I.DCE)
    alpha = trainlm$coefficients[1]
    beta = trainlm$coefficients[2]
    print(c(alpha,beta))
    ## the beta and alpha we use ##
    tblock_beta = round(beta,1)
    tblock_alpha = alpha
    tblock_resid = testdat$RB.SHF - testdat$I.DCE * tblock_beta - tblock_alpha
    ## the residul series ##
    trainresid = c(trainresid, trainlm$residuals)
    testresid = c(testresid,tblock_resid)
}
## plot ##
plot(trainresid,type = 'l')
## convert test resid as timeseries ##
resid_ts = timeSeries(testresid, as.Date(data[(block+1):(numblock*block),1]))
names(resid_ts) = c('testresid')
plot(resid_ts,type = 'l')
```

第一个图是回归对应的残差，可以看到其均值回复性相对很好。第二个图是将前一个120天回归的系数用于下一个120天时得到的价差，其均值回复性相对较差。以下为给定每个区块的价差序列、阈值后生成开仓平仓信号的函数。
```{r}
ocsig <- function(tsblk,gates){
    ## tsblk is the timeseries we operate on.
    ## gates consists of 4 parameters, namely a > b >c >d
    ##----initialize----##
    a = gates[1]
    b = gates[2]
    c = gates[3]
    d = gates[4]
    position_state = 0
    # position status: 1 for long the spread. -1 the opposite.
    Tts = length(tsblk)
    opsig = c()
    clsig = c()
    ##----find the sginals ----##
    for(i in 1:Tts){
        ## open signal ##
        if(tsblk[i] > a && position_state != -1 && i != Tts){
            ## i != Tts since we dont open on the last day.
            ## includes two cases: 0->-1 or 1->-1
            position_state = -1
            opsig = c(opsig,i*position_state)
        }
        else if(tsblk[i] < d && position_state != 1 && i !=Tts){
            ## includes two cases: 0->1 or -1->1
            position_state = 1
            opsig = c(opsig,i*position_state)
        }
        ##close signal ##
        else{
            if(tsblk[i] < b && position_state == -1 ){
                clsig = c(clsig,i)
                position_state = 0
            }
            if(tsblk[i] >c && position_state == 1){
                clsig = c(clsig,i)
                position_state = 0
            }
        }
    }
    if(position_state != 0){
        clsig = c(clsig, Tts)
    }
    #--------merge into one--------#
    if(length(opsig) > 0){
        mop = cbind(abs(opsig),sign(opsig))
        mcl = cbind(clsig,0)
        mpos = rbind(mop,mcl)
        colnames(mpos) = c('sig','sgn')
        mpos = mpos[order(mpos[,1]),] # sort by order,indicating the date
        mpos = rbind(c(0,0), mpos) # add a row indicating the initial state
        return(mpos)
    }
    else{
        print('no signal is found')
        return(c('No_Signal'))
    }
}
```

以下为上个函数的演示。
```{r}
trygates = c(50,20,-20,-50)
testseq1 = c(0,51,-60,-70,20,30,20,60,0,61)
testseq2 = rep(0,10)
A = ocsig(testseq2,trygates)
A
typeof(A)==c('character')
B = ocsig(resid_ts[1:block,],trygates)
B
typeof(B)==c('character')
```

于是可以画出其损益曲线。先画每个区块的再拼接为整体的。
```{r}
##define P&L
PLblk <- function(S, mpos){
    # S is the price series.
    # mpos should be the output matrix.
    P = c() 
    # P is the position series. P_0 = 0.lengh(P) = block + 1
    # P_k is the position state after the k_th day. 
    for(k in 2:dim(mpos)[1]){
        P = c(P, rep(mpos[k-1,2], (mpos[k,1]-mpos[k-1,1]) ) )
    }
    P = c(P,rep(0, 121-dim(mpos)[1] ))
    NV = rep(0,block)
    for(k in 2:block){
        NV[k] = NV[k-1] + (S[k]-S[k-1]) * P[k-1] 
    }
    return(NV)
}
```

```{r}
NV = resid_ts
for(k in 1:(numblock-1)){
    trainspread = trainresid[((k-1)*block+1):(k*block)]
    testspread =  resid_ts[((k-1)*block+1):(k*block)]
    std = sd(trainspread)
    ##--------CHOOSE THRESHOLD --------##
    threshold = c(2*std,0,0,-2*std)
    ##---------------------------------##
    mpos = ocsig(testspread, threshold)
    if(typeof(mpos)==c('character')){
        NV[((k-1)*block+1):(k*block)] = rep(0,block)
    }
    else{
        NV[((k-1)*block+1):(k*block)] = PLblk(testspread,mpos)
    }
    plot( NV[((k-1)*block+1):(k*block)], type='l')
}
##--------put together--------##
NVlong = NV
NVlong[1:block] = NV[1:block]
for(k in 2:(numblock-1)){
    temp = NVlong[(k-1)*block]
    NVlong[((k-1)*block+1):(k*block)] = temp + NV[((k-1)*block+1):(k*block)] 
}
#plot(NV,type='l')
plot(NVlong,type='l',ylab="P&L")
```
But what about the in-sample result?
```{r}
resid_train = timeSeries(trainresid, as.Date(data[1:(block*(numblock-1)),1]))
NV = resid_train
for(k in 1:(numblock-1)){
    trainspread = resid_train[((k-1)*block+1):(k*block)]
    testspread = resid_train[((k-1)*block+1):(k*block)]
    std = sd(trainspread)
    ##--------CHOOSE THRESHOLD --------##
    threshold = c(2*std,0,0,-2*std)
    ##---------------------------------##
    mpos = ocsig(testspread, threshold)
    if(typeof(mpos)==c('character')){
        NV[((k-1)*block+1):(k*block)] = rep(0,block)
    }
    else{
        NV[((k-1)*block+1):(k*block)] = PLblk(testspread,mpos)
    }
    #plot( NV[((k-1)*block+1):(k*block)], type='l')
}
##--------put together--------##
NVlong = NV
NVlong[1:block] = NV[1:block]
for(k in 2:(numblock-1)){
    temp = NVlong[(k-1)*block]
    NVlong[((k-1)*block+1):(k*block)] = temp + NV[((k-1)*block+1):(k*block)] 
}
plot(NV,type='l')
plot(NVlong,type='l',ylab="P&L")
```














